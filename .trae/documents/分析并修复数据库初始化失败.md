## 现状结论（基于代码库静态排查）
- 本项目“数据库初始化”不是外部 MySQL/Postgres，而是 Tauri 后端使用 SQLx 初始化本地 SQLite 文件 `memflow.db`。
- 初始化失败会在终端打印 `CRITICAL: Database init failed: ...`，并输出数据库路径提示，入口见 [lib.rs](file:///d:/Demo/memflow/src-tauri/src/lib.rs#L94-L116)。
- 失败点只可能发生在以下阶段之一（顺序固定），实现见 [db.rs](file:///d:/Demo/memflow/src-tauri/src/db.rs#L19-L456)：
  1) 创建目录（app_data_dir + screenshots）
  2) 连接 SQLite（WAL + busy_timeout）
  3) 执行迁移 `./migrations`（任意 migration 语法/版本/扩展问题都会失败）
  4) `PRAGMA integrity_check`
  5) “写入冒烟测试”（插入一条记录触发 FTS/触发器写路径）

## 你要的“终端输出/系统日志”应重点抓什么
- 终端关键标记（用于定位阶段）：
  - `Starting database initialization...`（开始）[lib.rs](file:///d:/Demo/memflow/src-tauri/src/lib.rs#L101-L116)
  - `开始执行数据库迁移...` / `数据库迁移失败:`（迁移阶段）[db.rs](file:///d:/Demo/memflow/src-tauri/src/db.rs#L388-L410)
  - `Integrity check failed`（完整性检查）[db.rs](file:///d:/Demo/memflow/src-tauri/src/db.rs#L413-L428)
  - `Write smoke test failed`（写入/FTS/触发器问题）[db.rs](file:///d:/Demo/memflow/src-tauri/src/db.rs#L430-L451)
  - `数据库连接失败，重试中...` / `database is locked`（锁/占用/并发）[db.rs](file:///d:/Demo/memflow/src-tauri/src/db.rs#L31-L86)
- 建议为“完整堆栈”开启：
  - `RUST_LOG=debug`（当前脚本只设了 info）[dev.ps1](file:///d:/Demo/memflow/scripts/dev.ps1#L21-L29)
  - `RUST_BACKTRACE=1`（anyhow/tauri 的错误链更可读）

## 结合代码对“可能原因”的映射（对应你列的 5 类）
- 数据库连接配置错误（本项目对应：路径/文件系统/打开方式）
  - 常见日志：`unable to open database file`、`invalid path`、`无法获取应用数据目录`。
  - 根因：app_data_dir 获取失败、路径不可写、路径被重定向到只读位置、WAL 文件创建失败。
- 权限不足
  - 可能发生点：`create_dir_all`（目录）或 SQLite 打开/创建 db、WAL/SHM 创建、恢复流程删除 db 失败。
  - 代码已有“删除失败诊断”与权限提示 [db.rs](file:///d:/Demo/memflow/src-tauri/src/db.rs#L527-L688)。
- 磁盘空间不足
  - SQLite 常见报错：`database or disk is full` / OS error（Windows 常见为 112）。
  - 影响点：创建 db / 写入 WAL / integrity_check/写入冒烟测试。
- 初始化脚本语法错误（本项目对应：sqlx migrations）
  - 发生点：`sqlx::migrate!`，日志会输出 `Database migration failed: ...`。
  - 高风险脚本：FTS5/触发器相关迁移：
    - 初始 FTS content-sync [0001_initial.sql](file:///d:/Demo/memflow/src-tauri/migrations/0001_initial.sql#L62-L81)
    - 转独立 FTS [0003_fix_fts_null_handling.sql](file:///d:/Demo/memflow/src-tauri/migrations/0003_fix_fts_null_handling.sql#L1-L19)
    - 恢复触发器 [0004_restore_fts_triggers.sql](file:///d:/Demo/memflow/src-tauri/migrations/0004_restore_fts_triggers.sql#L1-L28)
- 数据库版本不兼容（本项目对应：SQLite/FTS5 能力差异）
  - 典型报错：`no such module: fts5`、`unknown tokenizer: unicode61`。
  - 这会直接导致 migration 或写入冒烟测试失败（因为触发器/FTS 写入链路会报错）。

## 计划：完成你列的 6 步（含修改与验证）
### 1) 收集“完整终端错误输出 + 堆栈”
- 以 debug + backtrace 启动开发模式，捕获从 `Starting database initialization...` 到最终 `CRITICAL...` 的完整输出。
- 将输出按上述关键标记分段，记录：错误码/SQLite 错误信息/是否出现 `migration`/`integrity_check`/`smoke test`。

### 2) 定位“数据库日志文件/时间点”
- SQLite 本身默认没有独立日志文件；当前项目日志主要在 stdout/stderr。
- 我会补齐一个“落盘日志”方案：将初始化与恢复日志写入 `app_data_dir/logs/memflow.log`，这样测试/生产都能取证。

### 3) 给出根因判定分支（自动化判别）
- 基于错误字符串做分流：
  - `no such module: fts5`/`unicode61` → 归类为“版本/能力不兼容（FTS5 不可用）”
  - `unable to open database file`/PermissionDenied → 权限/路径问题
  - `database is locked` → 文件占用/并发
  - `disk is full` → 磁盘空间
  - `near ... syntax error` → 迁移脚本语法

### 4) 按根因修改配置或初始化脚本（会在你确认后落地改动）
- 诊断增强（必做）：
  - 日志输出 error chain（`{:?}`）+ backtrace 提示。
  - 增加落盘日志 writer（新增轻量依赖或自实现 writer）。
- 兼容性修复（按实际报错选择其一/组合）：
  - 若缺 FTS5：
    - 方案 A（推荐生产稳）：让 SQLite 始终带 FTS5（通过构建侧启用 bundled SQLite/FTS5 能力），避免环境差异。
    - 方案 B（功能降级）：迁移/冒烟测试在检测到 FTS5 不可用时跳过 FTS 初始化，并在搜索时退化为 LIKE 查询。
  - 若权限/锁：
    - 适当延长 busy_timeout、增加更清晰的“占用进程/路径”提示；必要时在恢复前先关闭 pool 并等待。
  - 若迁移脚本问题：
    - 修正对应 migration 的 SQL（语法、触发器逻辑、IF EXISTS/IF NOT EXISTS 顺序）。

### 5) 验证修改后的初始化是否成功
- 开发环境：启动后确认出现 `数据库迁移执行成功`、`Database checks passed.`、`Database initialization completed successfully.`。
- 增加一个最小自动化验证：启动后执行一次简单查询/插入（复用现有接口）确保写路径正常。

### 6) 覆盖测试环境与生产环境
- 测试环境：保持 debug 级别可开关（环境变量控制），日志落盘默认开启。
- 生产环境：默认 info 日志 + 落盘；出现初始化失败时，提示用户在日志目录取证并包含 db 路径。

## 我需要你确认后才能继续的事项
- 我将按上述计划新增“落盘日志”与“FTS5 兼容策略（优先 bundled 方案，其次降级方案）”，并在本仓库内完成改动与验证。