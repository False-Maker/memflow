## 已确定的优化方向（你认同的两点 + 我补充的点子）
- **A. OCR 队列化 + 背压**：采集侧只入队，不做 OCR；worker 侧限并发处理，失败重试。
- **B. 采集热路径去阻塞**：UIA/截图/编码/IO 不阻塞 Tokio 主循环。
- **C. OCR worker 并发与批处理**：并发执行 OCR、尽量 drain 队列。
- **D. 入队即唤醒（Notify）**：消除 5 秒轮询带来的端到端延迟。
- **E. OCR 前图像预处理（缩放/压缩）**：显著降低 OCR 成本（强推荐下一步做）。
- **F. 自适应采样频率**：静态场景降采集、交互场景保留密度，降低长期资源。
- **G. 多屏全景拼接拷贝优化**：降低多屏/高分辨率的 CPU/峰值内存。
- **H. DB 写放大再压缩**：降低 WAL 写入与写锁竞争（合并更新/批量统计）。

## 现状说明（为了“接着执行”先对齐边界）
- A/B/C/D 已在代码层面落地（队列化、spawn_blocking、worker 并发、Notify 唤醒 + drain）。
- 接下来要做的是 E/F/G/H 这四类“进一步榨性能”的增强，并补齐运行时验证与可观测性。

## 继续执行的具体实施方案（按收益/风险比排序）
### 1) 完成收尾验证（确保当前改动稳定）
- 跑完整回归：Rust 单测、基础启动检查。
- 运行 10~30 分钟真实采集：观察
  - `capture_and_save` 的 uia_ms/capture_ms/write_ms/db_ms/total_ms 分布
  - OCR 入队到回填的延迟（notify 后应接近 0）
  - ocr_queue 是否有长期 pending 积压

### 2) E：OCR 前图像预处理（缩放/重编码）
- **位置**：放在 worker 侧（ocr_worker）最安全，不影响采集主循环。
- **策略**：
  - 若图片像素数超过阈值：解码 → 等比例缩放到目标宽度（例如 1280/1600）→ 以更适合 OCR 的格式/质量上传。
  - 保留开关与参数（配置项），可快速回退。
- **验收**：ocr_ms 明显下降；文本质量抽样不劣化（或可接受）。

### 3) 增强可观测性：暴露队列统计与关键指标
- 新增一个 Tauri command 暴露 `ocr_queue` 统计（pending/processing/done/failed），用于前端或日志面板直观验证“是否积压”。
- 可选：增加 OCR 平均耗时/分位数的简单聚合（先日志后续再进 DB）。

### 4) F：自适应采样频率（降低长期资源）
- **策略**：
  - 结合窗口切换事件 + 最近键鼠活跃度（已有 focus_analytics）
  - 动态调节心跳采样间隔（例如 10s~60s）
  - 保留“最大间隔兜底”防漏录。

### 5) G：多屏全景拼接优化（针对重度多屏用户）
- **策略**：减少逐像素 collect 与中间 Vec 拷贝，改为更批量的拷贝/填充，降低峰值内存。
- **验收**：多屏场景 capture_ms 与内存峰值下降。

### 6) H：DB 写放大优化（更谨慎，最后做）
- **策略**：
  - OCR 回填合并（短时间内对同一 activity 的多次更新只保留最后一次）
  - skipped_stat 等计数做内存聚合后批量写入
- **验收**：写入锁等待减少、整体卡顿减少。

## 风险控制与回退
- 所有“激进”策略（预处理、自适应采样、写入合并）都通过配置开关控制。
- 任何异常可一键关闭回到当前稳定路径。

如果你确认这个“整理版+继续执行”的方案，我将退出 Plan Mode 并按 1→6 顺序继续把剩余 E/F/G/H 做完，同时完成运行时验证与指标补齐。